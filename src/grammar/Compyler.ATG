#include "../src/ir/irtuple.h"
#include <vector>
#include <map>
#include <string>
#include <wchar.h>
#include <iostream>

#define puts(...)

COMPILER Compyler

struct Symbol;
struct Function;
struct Parameter;
typedef vector<IRTuple*> Program;
typedef vector<Parameter> Paramlist;
typedef vector<wstring> LocList;
typedef map<wstring, wstring> Scope;

enum class ArgumentKind {
  SINGLE,
  FROM_TO,
  STEP
};

struct Function {
  wstring label;
  Paramlist params;
  wstring type;
  Program body;
};

struct Parameter {
  enum Kind{
    SINGLE_ARG,
    LIST_ARG,
    KW_ARG
  };

  Kind kind;
  wstring name;
  wstring type;
};

Program program;
vector<Scope> scopes;
vector<Function> functions;
vector<wstring> loopStart;
vector<wstring> loopExit;


int _label = 0;
wstring getLabel(){
  return L"L$" + to_wstring(_label++);
}

int _temp = 0;
wstring getTemp(){
  return L"T$" + to_wstring(_temp++);
}

wstring concatStrings(vector<wstring> strings){
  wstring res = L"";

  for (wstring str : strings){
    int len = str.size();
    bool isTriple = (len >= 6)  && (str[0] == str[len-1])
                                && (str[1] == str[len-2])
                                && (str[2] == str[len-3])
                                && (str[0] == str[1])
                                && (str[1] == str[2]);
    int from = isTriple ? 3 : 1;
    int to = isTriple ? len-4 : len-1;

    res += str.substr(from, to-from);
  }

  return res;
}

void showProg(){
  wstring res = L"";

  for (IRTuple *tup : program){
    res += show(*tup)+L"\n";
  }

  wcout << res << endl;
}


CHARACTERS
  Letter = 'a'..'z' + 'A'..'Z'.

  DecDigit = '0' .. '9'.
  BinDigit = "01".
  OctDigit = '0'..'7'.
  HexDigit = DecDigit + 'a'..'f' + 'A'..'F'.
  NonZeroDecDigit = DecDigit - '0'.

  ShortSingleStrChar = ANY - '\\' - '\'' - '\n'.
  ShortDoubleStrChar = ANY - '\\' - '\"' - '\n'.
  LongStrChar  = ANY - '\\'.


TOKENS
  NEWLINE = "¶".
  INDENT = "¬".
  DEDENT = '`'.
  Name = (Letter | '_') { Letter | '_' | DecDigit }.

  String = [('r' | 'R' | 'u' | 'U' | 'b' | 'B' | "br" | "rb")]             // optional prefix
           ( ('\'' { "\\\'" | "\\\\" | "\\\n" | ShortSingleStrChar } '\'') // short single
           | ('\"' { "\\\"" | "\\\\" | "\\\n" | ShortDoubleStrChar } '\"') // short double
           | ("\'\'\'" { "\\\\" | LongStrChar } "\'\'\'")                  // long single
           | ("\"\"\"" { "\\\\" | LongStrChar } "\"\"\"")                  // long double
           ).

  Number = ( ( NonZeroDecDigit {DecDigit} | '0' {'0'}) // decimalinteger
           | ( '0' ('o' | 'O') OctDigit {OctDigit})    // octinteger
           | ( '0' ('x' | 'X') HexDigit {HexDigit})    // hexinteger
           | ( '0' ('b' | 'B') BinDigit {BinDigit})    // bininteger
           | (                                         // float [exponent]
              ( (DecDigit {DecDigit} '.')
              | ({DecDigit} '.' DecDigit {DecDigit})
              )
              [ (('e' | 'E') ['+' | '-'] DecDigit {DecDigit}) ]
              [ 'j' | 'J']
             )
           | (                                         // bare exponent
              DecDigit {DecDigit}
              ('e' | 'E') ['+' | '-'] DecDigit {DecDigit}
              ['j' | 'J']
             )
           ).

COMMENTS FROM "#" TO '\n'

IGNORE '\t' + '\n'

PRODUCTIONS

/*------------------------------------------------------------------------*/

Compyler (. puts("Compyler"); .)
= { (NEWLINE | Stmt) }                        (.  for (Function func : functions){
                                                    program.push_back(new IRTuple(Operator::FUNC, L"", L"", func.label));
                                                    for (IRTuple* line: func.body){ //TODO: ignore empty funcs
                                                      program.push_back(line);
                                                    }
                                                  }
                                                  showProg();
                                              .) .

Decorator<wstring& loc> (. puts("Decorator"); .)
= '@' DottedName [ '(' [ArgList] ')' ] NEWLINE.

Decorators<LocList& decs> (. wstring loc = getTemp(); puts("Decorators"); .)
= Decorator<loc>        (. decs.push_back(loc); .)
  {                     (. loc = getTemp(); .)
    Decorator<loc>      (. decs.push_back(loc); .)
  }.

Decorated<wstring& name> (. vector<wstring> decs; Function func; puts("decorated"); .)
= Decorators<decs>
  ( ClassDef<name>
  | FuncDef<name, func>         (. functions.push_back(func); .)
  )                             (.
                                   for (wstring decorator : decs) {
                                     program.push_back(new IRTuple(Operator::CALL, L"", L"", decorator));
                                   }
                                .)
  .

FuncDef<wstring& name, Function& func> (. puts("FuncDef"); .)
= "def" Name                   (. name = t->val; func.label = getLabel(); .)
  '(' [ParamList<func.params>]
  ')' ["->" Test<func.type> ]
  ':'
  Suite<func.body>             (. func.body.push_back(new IRTuple(Operator::RET, L"", L"", L"None"));
                                  // functions always return None if no explicit return is seen
                                .).

ParamList <Paramlist& params> (. Parameter parameter; puts("paramList"); .)
= ( DefParam<parameter>        (. params.push_back(parameter); .)
    {                          (. parameter = Parameter(); .)
      ',' DefParam<parameter>  (. params.push_back(parameter); .)
    }
  | '*' [Param<parameter>      (. parameter.kind = Parameter::LIST_ARG; params.push_back(parameter); .)
        ]
    {                          (. parameter = Parameter(); .)
      ',' DefParam<parameter>  (. params.push_back(parameter); .)
    }
    [',' "**" Param<parameter> (. parameter.kind = Parameter::KW_ARG; params.push_back(parameter); .)
    ]
  | "**" Param<parameter>      (. parameter.kind = Parameter::KW_ARG; params.push_back(parameter); .)
  ).

Param<Parameter& param> (. wstring _ = getTemp(); puts("param"); .)
= Name [':' Test<_>].

DefParam<Parameter& param> (. wstring _ = getTemp(); puts("defparam"); .)
= Param<param> ['=' Test<_>].

LambdaParamList (. puts("LambdaParamList"); .)
= ( DefName {',' DefName}
  | '*' [Name] [',' {DefName ','} ["**" Name]]
  | "**" Name
  ).

DefName (. wstring _ = getTemp(); puts("defname"); .)
= Name ['=' Test<_>].

Stmt (. puts("Stmt"); .)
= (SimpleStmt | CompoundStmt).

SimpleStmt (. puts("SimpleStmt"); .)
= SmallStmt {';' SmallStmt} NEWLINE.

SmallStmt (. puts("SmallStmt"); .)
= ( ExprStmt
  | DelStmt
  | PassStmt
  | FlowStmt
  | ImportStmt
  | GlobalStmt
  | NonLocalStmt
  | AssertStmt
  ) .

ExprStmt (. wstring temp; Operator op; LocList left = LocList(); wstring right = getTemp(); puts("ExprStmt"); .)
= ( { Name                   (. temp = t -> val; .)
      { Ref<temp,temp> } '='
                             (. left.push_back(temp); .)
    }
    ( YieldExpr
    | Test<right>            (.
                                for (wstring ref : left) {
                                  program.push_back(new IRTuple(Operator::STORE, right, L"", ref));
                                }
                             .)
    )
  | Name                     (. temp = t -> val; .)
    { Ref<temp,temp> }
    ( "+="                   (. op = Operator::ADD;    .)
    | "-="                   (. op = Operator::SUB;    .)
    | "*="                   (. op = Operator::MUL;    .)
    | "/="                   (. op = Operator::DIV;    .)
    | "%="                   (. op = Operator::MOD;    .)
    | "&="                   (. op = Operator::AND;    .)
    | "|="                   (. op = Operator::OR;     .)
    | "^="                   (. op = Operator::XOR;    .)
    | "<<="                  (. op = Operator::LSHIFT; .)
    | ">>="                  (. op = Operator::RSHIFT; .)
    | "**="                  (. op = Operator::POW;    .)
    | "//="                  (. op = Operator::FDIV;   .)
    )
    ( YieldExpr
    | Test<right>            (. program.push_back(new IRTuple(Operator::STORE, right, L"", temp)); .)
    )
  ).

DelStmt (. wstring _; puts("DelStmt"); .)
= "del" (Expr<_>) {',' Expr<_>} .

PassStmt (. puts("PassStmt"); .)
= "pass".

FlowStmt (. puts("FlowStmt"); .)
= ( BreakStmt
  | ContinueStmt
  | ReturnStmt
  | RaiseStmt
  | YieldStmt
  ).

BreakStmt (. puts("BreakStmt"); .)
= "break"  (.
              if (loopExit.size() == 0) SemErr(L"Can't break outside of a loop");
              else program.push_back(new IRTuple(Operator::JMP, L"", L"", loopExit.back()));
           .) .

ContinueStmt (. puts("ContinueStmt"); .)
= "continue" (.
                if (loopStart.size() == 0) SemErr(L"Can't continue outside of a loop");
                else program.push_back(new IRTuple(Operator::JMP, L"", L"", loopStart.back()));
             .) .

ReturnStmt (. LocList locs; puts("ReturnStmt"); .)
= "return" [TestList<locs>  (.
                              if (locs.size() == 1){
                                program.push_back(new IRTuple(Operator::RET, L"", L"", locs[0]));
                              } else {
                                wstring returnList = getTemp();
                                program.push_back(new IRTuple(Operator::NEWM, L"", L"", returnList));
                                program.push_back(new IRTuple(Operator::STORE, to_wstring(locs.size()), L"0", returnList)); // store the lenght

                                int idx = 1;
                                for (auto loc : locs){
                                  program.push_back(new IRTuple(Operator::STORE, loc, to_wstring(idx++), returnList));
                                }

                                program.push_back(new IRTuple(Operator::RET, L"", L"", returnList));
                              }
                            .)
  ].

YieldStmt (. puts("YieldStmt"); .)
= YieldExpr.

RaiseStmt (. wstring _ = getTemp(); puts("RaiseStmt"); .)
= "raise" [Test<_> ["from" Test<_>]].

ImportStmt (. puts("ImportStmt"); .)
= ( "import" Module ["as" Name] {',' Module ["as" Name]}
  | "from" Module "import" ( '(' AsNames ')' | AsNames | '*' )
  ).

Module (. puts("Module"); .)
= ( DottedName
  | '.' {'.'} [Name]
  ).

AsNames (. puts("asNames"); .)
= Name ["as" Name] {',' Name ["as" Name]}.


DottedName (. puts("DottedName"); .)
= Name {'.' Name}.

GlobalStmt (. puts("GlobalStmt"); .)
= "global" Name {',' Name}.

NonLocalStmt (. puts("NonLocalStmt"); .)
= "nonlocal" Name {',' Name}.

AssertStmt (. LocList _; puts("AssertStmt"); .)
= "assert" TestList<_>.


CompoundStmt (. wstring name; Function func; puts("CompoundStmt"); .)
= ( IfStmt
  | WhileStmt
  | ForStmt
  | TryStmt
  | WithStmt
  | FuncDef<name, func>   (.
                             functions.push_back(func);
                             program.push_back(new IRTuple(Operator::STORE, func.label, L"", name));
                          .)
  | ClassDef<name>
  | Decorated<name>
  ).


IfStmt (. wstring testLoc = getTemp(); wstring endLabel = getLabel(); wstring elseLabel = getLabel(); Program body; puts("IfStmt"); .)
= "if" Test<testLoc> ':'    (. program.push_back(new IRTuple(Operator::JMPF, testLoc, L"", elseLabel)); .)
  Suite<body>               (.
                               for (IRTuple* line: body) program.push_back(line);
                               program.push_back(new IRTuple(Operator::JMP, L"", L"", endLabel));
                               program.push_back(label(elseLabel));
                             .)
  {"elif" Test<testLoc> ':' (. elseLabel = getLabel(); program.push_back(new IRTuple(Operator::JMPF, testLoc, L"", elseLabel)); .)
  Suite<body>               (.
                               for (IRTuple* line: body) program.push_back(line);
                               program.push_back(new IRTuple(Operator::JMPF, L"", L"", endLabel));
                               program.push_back(label(elseLabel));
                              .)
  } ["else" ':' Suite<body> (. for (IRTuple* line: body) program.push_back(line); .)
  ]                         (. program.push_back(label(endLabel)); .).

WhileStmt (. wstring testLoc = getTemp(); wstring endLabel = getLabel(); wstring startLabel = getLabel(); Program body; puts("WhileStmt"); .) //TODO: else
= "while"                 (. program.push_back(label(startLabel)); loopStart.push_back(startLabel); loopExit.push_back(endLabel); .)
  Test<testLoc> ':'       (. program.push_back(new IRTuple(Operator::JMPF, testLoc, L"", endLabel)); .)
  Suite<body>             (.
                             for (IRTuple* line: body) program.push_back(line);
                             program.push_back(new IRTuple(Operator::JMP, L"", L"", startLabel));
                             program.push_back(label(endLabel));
                           .)
  ["else" ':' Suite<body>] (. loopStart.pop_back(); loopExit.pop_back(); .).

ForStmt (. Program body; wstring bindName; wstring iter = getTemp(); wstring startLabel = getLabel(); wstring endLabel = getLabel(); wstring len = getTemp(); wstring shouldExit = getTemp(); puts("ForStmt"); .)
= "for" Name                          (. bindName = t->val; .)
  "in" Test<iter>                     (.
                                         wstring idx = getTemp();
                                         program.push_back(new IRTuple(Operator::LOAD, iter, L"0", len));
                                         program.push_back(new IRTuple(Operator::STORE, L"0", L"", idx));

                                         loopStart.push_back(startLabel);
                                         program.push_back(label(startLabel));
                                         program.push_back(new IRTuple(Operator::LOAD, iter, idx, bindName));
                                      .)
  ':' Suite<body>
                                      (.
                                         //todo: compare lengths here
                                         program.push_back(new IRTuple(Operator::ADD, idx, L"1", idx));

                                         program.push_back(new IRTuple(Operator::GT, idx, len, shouldExit));
                                         program.push_back(new IRTuple(Operator::JMPF, shouldExit, L"", startLabel));
                                         program.push_back(new IRTuple(Operator::JMP, L"", L"", endLabel));
                                      .)
  ["else" ':' Suite<body>
  ]                                   (. program.push_back(label(endLabel)); .).

TryStmt (. Program body; puts("TryStmt"); .)
= "try" ':' Suite<body> ( (((ExceptClause ':' Suite<body>) {(ExceptClause ':' Suite<body>)}) ["else" ':' Suite<body>] ["finally" ':' Suite<body>]) | "finally" ':' Suite<body>).

WithStmt (. Program body; puts("WithStmt"); .)
= "with" WithItem {',' WithItem} ':' Suite<body>.

WithItem (. wstring _ = getTemp(); puts("WithItem"); .)
= Test<_> ["as" Expr<_>].

ExceptClause (. wstring _ = getTemp(); puts("ExceptClause"); .)
= "except" [Test<_> ["as" Name]].

Suite <Program& body> (. puts("Suite"); .)
=                                       (. Program temp = program; program = Program(); .)
  (SimpleStmt
  | NEWLINE INDENT Stmt {Stmt} DEDENT
  )                                     (. body = program; program = temp; .)
  .


Test <wstring& location> (. puts("Test"); .)
= (OrTest <location>
    ["if"                         (. wstring temp1 = getTemp(); wstring temp2 = getTemp(); .)
      OrTest<temp1> "else" Test<temp2>
                                  (. wstring label = getLabel();
                                     program.push_back(new IRTuple(Operator::NOT, temp1, L"", temp1));
                                     program.push_back(new IRTuple(Operator::JMPF, temp1, L"", label));
                                     program.push_back(new IRTuple(Operator::STORE, temp2, L"", location));
                                     program.push_back(new IRTuple(Operator::LABEL, L"", L"", label));
                                  .)
    ]
  | LambDef
  ).

LambDef (. puts("LambDef"); .)
= "lambda" [LambdaParamList] ':' (. wstring _ = getTemp(); .) Test<_>.

OrTest <wstring& location> (. wstring temp=getTemp(); puts("OrTest"); .)
= AndTest <location>
  {"or" AndTest<temp> (. program.push_back(new IRTuple(Operator::OR, location, temp, location)); .)
  }.

AndTest <wstring& location> (. wstring temp=getTemp(); puts("AndTest"); .)
= NotTest <location>
  {"and" NotTest<temp> (. program.push_back(new IRTuple(Operator::AND, location, temp, location)); .)
  }.

NotTest <wstring& location> (. wstring temp=getTemp(); puts("NotTest"); .)
= ( "not" NotTest<temp> (. program.push_back(new IRTuple(Operator::NOT, temp, L"", location)); .)
  | Comparison<location>
  ).

Comparison <wstring& location> (. Operator op; wstring temp = getTemp(); puts("Comparison"); .)
= Expr<location>
  { CompOp<op>
    Expr<temp>       (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

CompOp <Operator& op> (. puts("CompOp");     .)
= ( '<'               (. op = Operator::LT;  .)
  | '>'               (. op = Operator::GT;  .)
  | "=="              (. op = Operator::EQU; .)
  | ">="              (. op = Operator::GTE; .)
  | "<="              (. op = Operator::LTE; .)
  | "<>"              (. op = Operator::NEQ; .)
  | "!="              (. op = Operator::NEQ; .)
  | ["not"] "in"      // TODO:
  | "is" ["not"]      // TODO:
  ).

Expr <wstring& location> (. wstring temp = getTemp(); puts("Expr"); .)
= XorExpr<location>
  {'|' XorExpr<temp> (. program.push_back(new IRTuple(Operator::OR, location, temp, location)); .)
  }.

XorExpr <wstring& location> (. wstring temp=getTemp(); puts("XorExpr"); .)
= AndExpr<location>
  {'^' AndExpr<temp> (. program.push_back(new IRTuple(Operator::XOR, location, temp, location)); .)
  }.

AndExpr <wstring& location> (. wstring temp=getTemp(); puts("AndExpr"); .)
= ShiftExpr<location>
  {'&' ShiftExpr<temp>  (. program.push_back(new IRTuple(Operator::AND, location, temp, location)); .)
  }.

ShiftExpr <wstring& location> (. Operator op; wstring temp=getTemp(); puts("ShiftExpr"); .)
= ArithExpr<location>
  { ("<<"              (. op = Operator::LSHIFT; .)
    |">>"              (. op = Operator::RSHIFT; .)
    ) ArithExpr<temp>   (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

ArithExpr <wstring& location> (. Operator op; wstring temp=getTemp(); puts("ArithExpr"); .)
= Term<location>
  { ('+'             (. op = Operator::ADD; .)
    |'-'             (. op = Operator::SUB; .)
    ) Term<temp>     (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

Term <wstring& location> (. Operator op; wstring temp=getTemp(); puts("Term"); .)
= Factor<location>
  { ('*'             (. op = Operator::MUL; .)
    |'/'             (. op = Operator::FDIV; .)
    |'%'             (. op = Operator::MOD; .)
    |"//"            (. op = Operator::DIV; .)
    ) Factor<temp>   (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

Factor <wstring& location>     (. wstring val; wstring temp=getTemp(); puts("Factor"); .)
= (                            (. int op; .)
    ( '+'                      (. op = 1; .) //plus operator in this context is basically noop
    | '-'                      (. op = 2; .)
    | '~'
    )                          (. op = 3; .)
    Factor<val>                (. switch(op){
                                    case 2:
                                      temp = getTemp();
                                      program.push_back(storeImmed(temp, L"0"));
                                      program.push_back(new IRTuple(Operator::SUB, temp, val, location));
                                      break;
                                    case 3:
                                      program.push_back(new IRTuple(Operator::NEG, val, L"", location));
                                      break;
                                    default:
                                      location = val;
                                  }
                                .)
  | Power<location>
  ).

Power <wstring& location> (. wstring loc; puts("Power"); .)
= AtomExpr<location> ["**" Factor<loc> (. program.push_back(new IRTuple(Operator::POW, location, loc, location)); .) ].

AtomExpr <wstring& location> (. puts("AtomExpr"); .)
= Atom<location> {Trailer<location, location>}.

Atom <wstring& location> (. LocList _;  puts("Atom"); .)
= ( '(' [(YieldExpr | List<location>)] ')'
  | '[' List<location> ']'
  | '{' [Dict<location> | Set<location>] '}'
  | Name                      (. program.push_back(new IRTuple(Operator::LOAD, t->val, L"", location)); .)
  | Number                    (. program.push_back(storeImmed(location, t->val)); .)
  | "..."                     (. program.push_back(storeImmed(location, L"...")); .)
  | "None"                    (. program.push_back(storeImmed(location, L"None")); .)
  | "True"                    (. program.push_back(storeImmed(location, L"True")); .)
  | "False"                   (. program.push_back(storeImmed(location, L"False")); .)
  | (                         (. vector<wstring> strs; .)
      String                  (. strs.push_back(t->val); .)
    { String                  (. strs.push_back(t->val); .)
    }
    )                         (. program.push_back(storeImmed(location, concatStrings(strs))); .)
  ).

List<wstring& location> (. wstring val = getTemp(); int idx = 1; .)
=                                (.
                                    location = getTemp();
                                    program.push_back(new IRTuple(Operator::NEWM, L"", L"", location));
                                 .)
  Expr<val>                      (. program.push_back(new IRTuple(Operator::STORE, val, to_wstring(idx++), location)); .)
  {                              (. val = getTemp(); .)
    ',' Expr<val>                (. program.push_back(new IRTuple(Operator::STORE, val, to_wstring(idx++), location)); .)
  }                              (. program.push_back(new IRTuple(Operator::STORE, to_wstring(idx), L"0", location)); .).

Dict<wstring& location> (. wstring key = getTemp(); wstring val = getTemp(); wstring keyHash = getTemp(); .)
=                                (.
                                    location = getTemp();
                                    program.push_back(new IRTuple(Operator::NEWM, L"", L"", location));
                                 .)
  Expr<key> ':' Expr<val>        (. program.push_back(new IRTuple(Operator::STORE, val, key, keyHash)); .)
  { ',' Expr<key> ':' Expr<val>  (. program.push_back(new IRTuple(Operator::STORE, val, key, keyHash)); .)
  }.

Set<wstring& location> (. wstring val = getTemp(); wstring idx = getTemp(); .)
=                      (.
                          location = getTemp();
                          program.push_back(new IRTuple(Operator::NEWM, L"", L"", location));
                       .)
  Expr<val>            (. program.push_back(new IRTuple(Operator::STORE, val, val, location)); .)
  {',' Expr<val>       (. program.push_back(new IRTuple(Operator::STORE, val, val, location)); .)
  }.



Trailer<wstring base, wstring& loc> (. puts("Trailer"); .)
= ( '(' [ ArgList
        ]
    ')'
  | Ref<base, loc>
  ).

Ref<wstring base, wstring& loc>
= (                                       (. ArgumentKind kind; wstring from = L""; wstring to = L""; wstring step = L""; .)
    '[' Subscript<kind, from, to, step>   (.
                                             if (kind == ArgumentKind::SINGLE){
                                                program.push_back(new IRTuple(Operator::ADD, base, from, loc));
                                             } else {
                                                if(from == L""){ // default 'from' address is 0
                                                  from = getTemp();
                                                  program.push_back(new IRTuple(Operator::STORE, L"0", L"", from));
                                                }

                                                if(to == L""){ // default 'to' address is the length of the given list
                                                  to = getTemp();
                                                  program.push_back(new IRTuple(Operator::LOAD, base, L"0", to));
                                                }

                                                if(step == L"") { // default 'step' is 1
                                                  step = getTemp();
                                                  program.push_back(new IRTuple(Operator::STORE, L"1", L"", step));
                                                }

                                                wstring loopStart = getLabel();
                                                wstring loopEnd = getLabel();
                                                wstring loopCond = getTemp();
                                                wstring temp = getTemp();

                                                program.push_back(label(loopStart));
                                                program.push_back(new IRTuple( Operator::GTE, from, to, loopCond));
                                                program.push_back(new IRTuple( Operator::JMPF, loopCond, L"", loopEnd));
                                                program.push_back(new IRTuple( Operator::LOAD, base, from, temp));
                                                program.push_back(new IRTuple( Operator::STORE, temp, from, loc));
                                                program.push_back(new IRTuple( Operator::JMP, L"", L"", loopStart));
                                                program.push_back(label(loopEnd));
                                             }
                                          .)


    ']'
  | '.' Name                              (. program.push_back(new IRTuple( Operator::LOAD, base, t->val, loc)); .)
  ).

Subscript<ArgumentKind& kind, wstring& from, wstring& to, wstring& step> (. puts("Subscript"); .)
= ( Test<from>                     (. kind = ArgumentKind::SINGLE; .)
    [':'                           (. kind = ArgumentKind::FROM_TO; .)
      [SliceOp<kind, to, step>]
    ]
  | ':'                            (. kind = ArgumentKind::FROM_TO; .)
    [SliceOp<kind, to, step>]
  ).

SliceOp<ArgumentKind& kind, wstring& to, wstring& step> (. wstring _ = getTemp(); puts("sliceop"); .)
= ( ':' [Test<step>     (. kind = ArgumentKind::STEP; .)
        ]
  | Test<to>
    [':'
      [Test<step>       (. kind = ArgumentKind::STEP; .)
      ]
    ]
  ).

TestList<LocList& locs> (. wstring loc = getTemp(); puts("TestList"); .)
= Test<loc>             (. locs.push_back(loc); .)
  {',' Test<loc>        (. locs.push_back(loc); .)
  }.


ClassDef<wstring& name> (. Program body; puts("ClassDef"); .)
= "class" Name [ '(' [ArgList] ')' ] ':' Suite<body>.

ArgList (. wstring _ = getTemp(); puts("ArgList"); .)
= Test<_> ['=' Test<_>] {',' Test<_> ['=' Test<_>]}.

YieldExpr (. wstring _; puts("YieldExpr"); .)
= "yield" Test<_>.

END Compyler.
