#include "../src/ir/irtuple.h"
#include <vector>
#include <map>
#include <string>
#include <wchar.h>
#include <iostream>

#define puts(...)

COMPILER Compyler

struct Symbol;
struct Function;
struct Param;
typedef vector<IRTuple*> Program;
typedef vector<Param> Paramlist;
typedef vector<wstring> LocList;
typedef map<wstring, wstring> Scope;

struct Function {
  public:
    wstring label;
    vector<Param> params;
    wstring type;
    Program body;
};

struct Param {
  public:
    enum Kind{
      SINGLE_ARG,
      LIST_ARG,
      KW_ARG
    };

    Kind kind;
    wstring name;
    wstring type;

};

Program program;
vector<Scope> scopes;
vector<Function> functions;


int _label = 0;
wstring getLabel(){
  return L"L$" + to_wstring(_label++);
}

int _temp = 0;
wstring getTemp(){
  return L"T$" + to_wstring(_temp++);
}

void showProg(){
  wstring res = L"";

  for (IRTuple *tup : program){
    res += show(*tup)+L"\n";
  }

  wcout << res << endl;
}


CHARACTERS
  Letter = 'a'..'z' + 'A'..'Z'.

  DecDigit = '0' .. '9'.
  BinDigit = "01".
  OctDigit = '0'..'7'.
  HexDigit = DecDigit + 'a'..'f' + 'A'..'F'.
  NonZeroDecDigit = DecDigit - '0'.

  ShortSingleStrChar = ANY - '\\' - '\'' - '\n'.
  ShortDoubleStrChar = ANY - '\\' - '\"' - '\n'.
  LongStrChar  = ANY - '\\'.


TOKENS
  NEWLINE = "¶".
  INDENT = "¬".
  DEDENT = '`'.
  Name = (Letter | '_') { Letter | '_' | DecDigit }.

  String = [('r' | 'R' | 'u' | 'U' | 'b' | 'B' | "br" | "rb")]             // optional prefix
           ( ('\'' { "\\\'" | "\\\\" | "\\\n" | ShortSingleStrChar } '\'') // short single
           | ('\"' { "\\\"" | "\\\\" | "\\\n" | ShortDoubleStrChar } '\"') // short double
           | ("\'\'\'" { "\\\\" | LongStrChar } "\'\'\'")                  // long single
           | ("\"\"\"" { "\\\\" | LongStrChar } "\"\"\"")                  // long double
           ).

  Number = ( ( NonZeroDecDigit {DecDigit} | '0' {'0'}) // decimalinteger
           | ( '0' ('o' | 'O') OctDigit {OctDigit})    // octinteger
           | ( '0' ('x' | 'X') HexDigit {HexDigit})    // hexinteger
           | ( '0' ('b' | 'B') BinDigit {BinDigit})    // bininteger
           | (                                         // float [exponent]
              ( (DecDigit {DecDigit} '.')
              | ({DecDigit} '.' DecDigit {DecDigit})
              )
              [ (('e' | 'E') ['+' | '-'] DecDigit {DecDigit}) ]
              [ 'j' | 'J']
             )
           | (                                         // bare exponent
              DecDigit {DecDigit}
              ('e' | 'E') ['+' | '-'] DecDigit {DecDigit}
              ['j' | 'J']
             )
           ).

COMMENTS FROM "#" TO '\n'

IGNORE '\t' + '\n'

PRODUCTIONS

/*------------------------------------------------------------------------*/

Compyler (. puts("Compyler"); .)
= { (NEWLINE | Stmt) }                        (.  for (Function func : functions){
                                                    program.push_back(new IRTuple(Operator::FUNC, L"", L"", func.label));
                                                    for (IRTuple* line: func.body){ //TODO: ignore empty funcs
                                                      program.push_back(line);
                                                    }
                                                  }
                                                  showProg();
                                              .) .

Decorator (. puts("Decorator"); .)
= '@' DottedName [ '(' [ArgList] ')' ] NEWLINE.

Decorators (. puts("Decorators"); .)
= Decorator {Decorator}.

Decorated (. Function func; puts("decorated"); .)
= Decorators
  ( ClassDef
  |                             (. wstring name; Function func; .)
    FuncDef<name, func>         (. functions.push_back(func); .)
  |                             (. wstring name; Function async; .)
    AsyncFuncDef<name, async>   (. functions.push_back(async); .)
  ).

AsyncFuncDef<wstring& name, Function& func> (. puts("asyncfuncdef"); .)
= "async" FuncDef<name, func>.

FuncDef<wstring& name, Function& func> (. puts("FuncDef"); .)
= "def" Name                   (. name = t->val; func.label = getLabel(); .)
  '(' [ParamList<func.params>]
  ')' ["->" Test<func.type>
  ] ':'
  Suite<func.body>             (. func.body.push_back(new IRTuple(Operator::RET, L"", L"", L"None"));
                                  // functions always return None if no explicit return is seen
                                .).

ParamList <Paramlist& params> (. puts("paramList"); .)
= ( DefParam {',' DefParam}
  | '*' [Param] [',' {DefParam ','} ["**" Param]]
  | "**" Param
  ).

Param (. wstring _ = getTemp(); puts("param"); .)
= Name [':' Test<_>].

DefParam (. wstring _ = getTemp(); puts("defparam"); .)
= Param ['=' Test<_>].

LambdaParamList (. puts("LambdaParamList"); .)
= ( DefName {',' DefName}
  | '*' [Name] [',' {DefName ','} ["**" Name]]
  | "**" Name
  ).

DefName (. wstring _ = getTemp(); puts("defname"); .)
= Name ['=' Test<_>].

Stmt (. puts("Stmt"); .)
= (SimpleStmt | CompoundStmt).

SimpleStmt (. puts("SimpleStmt"); .)
= SmallStmt {';' SmallStmt} NEWLINE.

SmallStmt (. puts("SmallStmt"); .)
= ( ExprStmt
  | DelStmt
  | PassStmt
  | FlowStmt
  | ImportStmt
  | GlobalStmt
  | NonLocalStmt
  | AssertStmt
  ) .

ExprStmt (. wstring _ = getTemp(); wstring loc1 = getTemp(); wstring loc2 = getTemp(); puts("ExprStmt"); .)
= TestListStarExpr<loc1>
  ( (AugAssign (YieldExpr | TestList<_>))
  | {
      ('=' (YieldExpr
           | TestListStarExpr<loc2>   (. program.push_back(new IRTuple(Operator::STORE, loc2, L"", loc1)); .)
           )
      )
    }
  ).

TestListStarExpr<wstring& _> (. puts("TestListStarExpr"); .)
= (Test<_> | StarExpr<_>) {',' (Test<_> | StarExpr<_>)}.

AugAssign (. puts("AugAssign"); .)
= ( "+="
  | "-="
  | "*="
  | "@="
  | "/="
  | "%="
  | "&="
  | "|="
  | "^="
  | "<<="
  | ">>="
  | "**="
  | "//="
  ).

DelStmt (. puts("DelStmt"); .)
= "del" ExprList.

PassStmt (. puts("PassStmt"); .)
= "pass".

FlowStmt (. puts("FlowStmt"); .)
= ( BreakStmt
  | ContinueStmt
  | ReturnStmt
  | RaiseStmt
  | YieldStmt
  ).

BreakStmt (. puts("BreakStmt"); .)
= "break".

ContinueStmt (. puts("ContinueStmt"); .)
= "continue".

ReturnStmt (. wstring loc = getTemp(); puts("ReturnStmt"); .)
= "return" [TestList<loc>    (. program.push_back(new IRTuple(Operator::RET, L"", L"", loc)); .)
  ].

YieldStmt (. puts("YieldStmt"); .)
= YieldExpr.

RaiseStmt (. wstring _ = getTemp(); puts("RaiseStmt"); .)
= "raise" [Test<_> ["from" Test<_>]].

ImportStmt (. puts("ImportStmt"); .)
= ( "import" Module ["as" Name] {',' Module ["as" Name]}
  | "from" Module "import" ( '(' AsNames ')' | AsNames | '*' )
  ).

Module (. puts("Module"); .)
= ( DottedName
  | '.' {'.'} [Name]
  ).

AsNames (. puts("asNames"); .)
= Name ["as" Name] {',' Name ["as" Name]}.


DottedName (. puts("DottedName"); .)
= Name {'.' Name}.

GlobalStmt (. puts("GlobalStmt"); .)
= "global" Name {',' Name}.

NonLocalStmt (. puts("NonLocalStmt"); .)
= "nonlocal" Name {',' Name}.

AssertStmt (. puts("AssertStmt"); .) // TODO:
= "assert".


CompoundStmt (. puts("CompoundStmt"); .)
= ( IfStmt
  | WhileStmt
  | ForStmt
  | TryStmt
  | WithStmt
  |                       (. wstring name; Function func; .)
    FuncDef<name, func>   (.
                             functions.push_back(func);
                             program.push_back(new IRTuple(Operator::STORE, func.label, L"", name));
                          .)
  | ClassDef
  | Decorated
  | AsyncStmt
  ).

AsyncStmt (. puts("AsyncStmt"); .)
= "async" ((. wstring name; Function func; .) FuncDef<name, func> | WithStmt | ForStmt).

IfStmt (. wstring testLoc = getTemp(); wstring endLabel = getLabel(); wstring elseLabel = getLabel(); Program body; puts("IfStmt"); .)
= "if" Test<testLoc> ':'    (. program.push_back(new IRTuple(Operator::JMPF, testLoc, L"", elseLabel)); .)
  Suite<body>               (.
                               for (IRTuple* line: body) program.push_back(line);
                               program.push_back(new IRTuple(Operator::JMP, L"", L"", endLabel));
                               program.push_back(label(elseLabel));
                             .)
  {"elif" Test<testLoc> ':' (. elseLabel = getLabel(); program.push_back(new IRTuple(Operator::JMPF, testLoc, L"", elseLabel)); .)
  Suite<body>               (.
                               for (IRTuple* line: body) program.push_back(line);
                               program.push_back(new IRTuple(Operator::JMPF, L"", L"", endLabel));
                               program.push_back(label(elseLabel));
                              .)
  } ["else" ':' Suite<body> (. for (IRTuple* line: body) program.push_back(line); .)
  ]                         (. program.push_back(label(endLabel)); .).

WhileStmt (. wstring testLoc = getTemp(); wstring endLabel = getLabel(); wstring startLabel = getLabel(); Program body; puts("WhileStmt"); .) //TODO: else
= "while"                 (. program.push_back(label(startLabel)); .)
  Test<testLoc> ':'       (. program.push_back(new IRTuple(Operator::JMPF, testLoc, L"", endLabel)); .)
  Suite<body>             (.
                             for (IRTuple* line: body) program.push_back(line);
                             program.push_back(new IRTuple(Operator::JMP, L"", L"", startLabel));
                             program.push_back(label(endLabel));
                           .)
  ["else" ':' Suite<body>].

ForStmt (. Program body; wstring _ = getTemp(); puts("ForStmt"); .)
= "for" ExprList "in" TestList<_> ':' Suite<body> ["else" ':' Suite<body>].

TryStmt (. Program body; puts("TryStmt"); .)
= "try" ':' Suite<body> ( (((ExceptClause ':' Suite<body>) {(ExceptClause ':' Suite<body>)}) ["else" ':' Suite<body>] ["finally" ':' Suite<body>]) | "finally" ':' Suite<body>).

WithStmt (. Program body; puts("WithStmt"); .)
= "with" WithItem {',' WithItem} ':' Suite<body>.

WithItem (. wstring _ = getTemp(); puts("WithItem"); .)
= Test<_> ["as" Expr<_>].

ExceptClause (. wstring _ = getTemp(); puts("ExceptClause"); .)
= "except" [Test<_> ["as" Name]].

Suite <Program& body> (. puts("Suite"); .)
=                                       (. Program temp = program; program = Program(); .)
  (SimpleStmt
  | NEWLINE INDENT Stmt {Stmt} DEDENT
  )                                     (. body = program; program = temp; .)
  .


Test <wstring& location> (. puts("Test"); .)
= (OrTest <location>
    ["if"                         (. wstring temp1 = getTemp(); wstring temp2 = getTemp(); .)
      OrTest<temp1> "else" Test<temp2>
                                  (. wstring label = getLabel();
                                     program.push_back(new IRTuple(Operator::NOT, temp1, L"", temp1));
                                     program.push_back(new IRTuple(Operator::JMPF, temp1, L"", label));
                                     program.push_back(new IRTuple(Operator::STORE, temp2, L"", location));
                                     program.push_back(new IRTuple(Operator::LABEL, L"", L"", label));
                                  .)
    ]
  | LambDef
  ).

TestNoCond <wstring& location> (. puts("TestNoCond"); .)
= (OrTest<location> | LambDefNoCond).

LambDef (. puts("LambDef"); .)
= "lambda" [LambdaParamList] ':' (. wstring _ = getTemp(); .) Test<_>.

LambDefNoCond (. puts("LambDefNoCond"); .)
= "lambda" [LambdaParamList] ':' (. wstring _ = getTemp(); .) TestNoCond<_>.

OrTest <wstring& location> (. wstring temp=getTemp(); puts("OrTest"); .)
= AndTest <location>
  {"or" AndTest<temp> (. program.push_back(new IRTuple(Operator::OR, location, temp, location)); .)
  }.

AndTest <wstring& location> (. wstring temp=getTemp(); puts("AndTest"); .)
= NotTest <location>
  {"and" NotTest<temp> (. program.push_back(new IRTuple(Operator::AND, location, temp, location)); .)
  }.

NotTest <wstring& location> (. wstring temp=getTemp(); puts("NotTest"); .)
= ( "not" NotTest<temp> (. program.push_back(new IRTuple(Operator::NOT, temp, L"", location)); .)
  | Comparison<location>
  ).

Comparison <wstring& location> (. Operator op; wstring temp = getTemp(); puts("Comparison"); .)
= Expr<location>
  { CompOp<op>
    Expr<temp>       (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

CompOp <Operator& op> (. puts("CompOp");     .)
= ( '<'               (. op = Operator::LT;  .)
  | '>'               (. op = Operator::GT;  .)
  | "=="              (. op = Operator::EQU; .)
  | ">="              (. op = Operator::GTE; .)
  | "<="              (. op = Operator::LTE; .)
  | "<>"              (. op = Operator::NEQ; .)
  | "!="              (. op = Operator::NEQ; .)
  | ["not"] "in"      // TODO:
  | "is" ["not"]      // TODO:
  ).

StarExpr <wstring& location> (. puts("StarExpr"); .) //TODO:
= "*" Expr<location>.

Expr <wstring& location> (. wstring temp = getTemp(); puts("Expr"); .)
= XorExpr<location>
  {'|' XorExpr<temp> (. program.push_back(new IRTuple(Operator::OR, location, temp, location)); .)
  }.

XorExpr <wstring& location> (. wstring temp=getTemp(); puts("XorExpr"); .)
= AndExpr<location>
  {'^' AndExpr<temp> (. program.push_back(new IRTuple(Operator::XOR, location, temp, location)); .)
  }.

AndExpr <wstring& location> (. wstring temp=getTemp(); puts("AndExpr"); .)
= ShiftExpr<location>
  {'&' ShiftExpr<temp>  (. program.push_back(new IRTuple(Operator::AND, location, temp, location)); .)
  }.

ShiftExpr <wstring& location> (. Operator op; wstring temp=getTemp(); puts("ShiftExpr"); .)
= ArithExpr<location>
  { ("<<"              (. op = Operator::LSHIFT; .)
    |">>"              (. op = Operator::RSHIFT; .)
    ) ArithExpr<temp>   (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

ArithExpr <wstring& location> (. Operator op; wstring temp=getTemp(); puts("ArithExpr"); .)
= Term<location>
  { ('+'             (. op = Operator::ADD; .)
    |'-'             (. op = Operator::SUB; .)
    ) Term<temp>     (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

Term <wstring& location> (. Operator op; wstring temp=getTemp(); puts("Term"); .)
= Factor<location>
  { ('*'             (. op = Operator::MUL; .)
    |'/'             (. op = Operator::FDIV; .)
    |'%'             (. op = Operator::MOD; .)
    |"//"            (. op = Operator::DIV; .)
    ) Factor<temp>   (. program.push_back(new IRTuple(op, location, temp, location)); .)
  }.

Factor <wstring& location>     (. wstring val; wstring temp=getTemp(); puts("Factor"); .)
= (                            (. int op; .)
    ('+'                       (. op = 1; .) //plus operator in this context is basically noop
    |'-'                       (. op = 2; .)
    |'~')                      (. op = 3; .)
    Factor<val>                (. switch(op){
                                    case 2:
                                      temp = getTemp();
                                      program.push_back(storeImmed(temp, L"0"));
                                      program.push_back(new IRTuple(Operator::SUB, temp, val, location));
                                      break;
                                    case 3:
                                      program.push_back(new IRTuple(Operator::NEG, val, L"", location));
                                      break;
                                    default:
                                      location = val;
                                  }
                                .)
  | Power<location>
  ).

Power <wstring& location> (. wstring loc; puts("Power"); .)
= AtomExpr<location> ["**" Factor<loc> (. program.push_back(new IRTuple(Operator::POW, location, loc, location)); .) ].

AtomExpr <wstring& location> (. puts("AtomExpr"); .) //TODO: trailers
= ["await"] Atom<location> {Trailer}.

Atom <wstring& location> (. puts("Atom"); .) //TODO: remaining atoms
= ( '(' [(YieldExpr | TestListComp)] ')'
  | '[' [TestListComp] ']'
  | '{' [DictOrSetMaker] '}'
  | Name                      (. program.push_back(new IRTuple(Operator::LOAD, t->val, L"", location)); .)
  | Number                    (. program.push_back(storeImmed(location, t->val)); .)
  | (String {String})
  | "..."                     (. program.push_back(storeImmed(location, L"...")); .)
  | "None"                    (. program.push_back(storeImmed(location, L"None")); .)
  | "True"                    (. program.push_back(storeImmed(location, L"True")); .)
  | "False"                   (. program.push_back(storeImmed(location, L"False")); .)
  ).

DictOrSetMaker (. wstring _ = getTemp(); puts("DictOrSetMaker"); .)
= ( Test<_> ( ':' Test<_> (CompFor | {',' (Test<_> ':' Test<_> | "**" Expr<_>)})
         | CompFor
         | {',' (Test<_> | StarExpr<_>)}
         )
  | "**" Expr<_> (CompFor | {',' (Test<_> ':' Test<_> | "**" Expr<_>)})
  ).



TestListComp (. wstring _ = getTemp(); puts("TestListComp"); .)
= (Test<_> | StarExpr<_>) (CompFor | {',' (Test<_> | StarExpr<_>)}).

Trailer (. puts("Trailer"); .)
= ('(' [ArgList] ')' | '[' SubscriptList ']' | '.' Name).

SubscriptList (. puts("SubscriptList"); .)
= Subscript {',' Subscript}.

Subscript (. wstring _ = getTemp(); puts("Subscript"); .)
= ( Test<_> [':' [SliceOp]]
  | ':' [SliceOp]
  ).

SliceOp (. wstring _ = getTemp(); puts("sliceop"); .)
= ( ':' [Test<_>]
  | Test<_> [':' [Test<_>]]
  ).


ExprList (. wstring _ = getTemp(); puts("ExprList"); .)
= (Expr<_> | StarExpr<_>) {',' Expr<_> | StarExpr<_>} .

TestList<wstring& loc> (. wstring _ = getTemp(); puts("TestList"); .)
= Test<loc> [','] [TestList<_>].



ClassDef (. Program body; puts("ClassDef"); .)
= "class" Name [ '(' [ArgList] ')' ] ':' Suite<body>.

ArgList (. puts("ArgList"); .)
= Argument [','] [ArgList].

Argument (. wstring _ = getTemp(); puts("Argument"); .)
= ( Test<_> ('=' Test<_> | [CompFor])
  | "**" Test<_>
  | '*' Test<_>
  ).

CompIter (. puts("CompIter"); .)
= (CompFor | CompIf).

CompFor (. wstring _ =getTemp(); puts("CompFor"); .)
= "for" ExprList "in" OrTest<_> [CompIter].

CompIf (. wstring _ = getTemp(); puts("CompIf"); .)
= "if" TestNoCond<_> [CompIter].

YieldExpr (. puts("YieldExpr"); .)
= "yield" [YieldArg].

YieldArg (. wstring _ = getTemp(); puts("YieldArg"); .)
= ("from" Test<_> | TestList<_>).

END Compyler.
